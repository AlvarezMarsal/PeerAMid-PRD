using System.Diagnostics;
using System.Text.Json;

namespace AssemblyInfoRewriter;

internal class Program
{
    private static readonly Dictionary<string, object> Values = new ();
    private static readonly DateTime Now = DateTime.Now;
    private static readonly string Signature = "// Generated by AssemblyInfoRewriter";

    static void Main(string[] args)
    {
        if (args.Length != 3)
        {
            Console.WriteLine("Usage: AssemblyInfoRewriter <folder> <configuration> <company>");
            return;
        }

        var folder = Path.GetFullPath(args[0]);
        var y2000 = new DateTime((Now.Year / 100) * 100, 1, 1, 0, 0, 0);
        var sunday = DateTime.Now.AddDays(-((int) DateTime.Now.DayOfWeek));
        sunday = new DateTime(sunday.Year, sunday.Month, sunday.Day, 0, 0, 0);
        Values["configuration"] = args[1];
        Values["company"] = args[2];
        Values["year"] = Now.Year;
        Values["cyear"] = Now.Year % 100;
        Values["month"] = Now.Month;
        Values["cmonth"] = ((Now.Year % 100) * 12) + Now.Month;
        Values["day"] = Now.Day;
        Values["yday"] = Now.DayOfYear;
        Values["cday"] = (int)((Now - y2000).TotalDays);
        Values["cminute"] = (Now - y2000).TotalMinutes;
        Values["hour"] = Now.Hour;
        Values["minute"] = Now.Minute;
        Values["mmdd"] = Now.Month * 100 + Now.Day;
        Values["second"] = Now.Second;
        var dminute = Now.Hour * 60 + Now.Minute;
        Values["dminute"] = dminute;
        Values["dsecond"] = (dminute * 60) + Now.Second;
        var yymm = (Now.Year % 100) * 100 + Now.Month;
        Values["yymm"] = yymm;
        //Values["yymmdd"] = yymm * 100 + Now.Day;
        Values["hhmm"] = Now.Hour * 100 + Now.Minute;
        var ddhh = Now.Day * 100 + Now.Hour;
        Values["ddhh"] = ddhh;
        //Values["ddhhmm"] = Now.Day * 10000 + Now.Hour * 100 + Now.Minute;
        var dcentury = (int)((Now - y2000).TotalDays);
        Values["dcentury"] = ddhh;
        var wcentury = 1 + ((dcentury+1) / 7); //2000 -01-01 is a Saturday
        Values["wcentury"] = wcentury;  // weeks since the beginning of the century
        var hweek = (int)((Now - sunday).TotalHours);
        Values["hweek"] = hweek;
        var mweek = (int)((Now - sunday).TotalMinutes); 
        Values["mweek"] = mweek; // minutes since Sunday of this week

        var f = Path.Combine(folder, "Branch.json");
        if (File.Exists(f))
        {
            var json = JsonDocument.Parse(File.ReadAllText(f));
            foreach (var j in json.RootElement.EnumerateObject())
            {
                Values[j.Name] = j.Value.ToString();
            }
        }


        CheckFolder(folder);
    }

    private static void CheckFolder(string folder)
    {
        var ai = Path.Combine(folder, "AssemblyInfo.cs");
        if (File.Exists(ai))
        {
            //var gitDate = GetGitDate(ai);
            //Values["gy"] = (gitDate.Year % 100).ToString("D2");
            //Values["gm"] = (gitDate.Month % 100).ToString("D2");
            //Values["gd"] = (gitDate.Day % 100).ToString("D2");
            //var gitRevision= GetGitRevision(Path.GetDirectoryName(ai)!);
            //Values["gitrev"] = gitRevision;
            //var gitrevnum = GenerateGitRevNum(gitDate);
            //Values["gitrevnum"] = gitrevnum;

            ProcessFile(ai);
        }
        else
        {
            throw new Exception($"No AssemblyInfo.cs file in '{folder}'");
        }
    }

    private static void ProcessFile(string filename)
    {
        var input = File.ReadAllLines(filename);
        var output = new List<string>(input.Length);
        var changed = false;
        foreach (var line in input)
        {
            if (string.IsNullOrEmpty(line))
            {
                output.Add(string.Empty);
            }
            else if (line.EndsWith(Signature))
            {
                // skip
            }
            else
            {
                var l = line.Trim();
                if (l.StartsWith("//["))
                {
                    output.Add(l);
                    l = ReplaceValues(l);
                    if (l != line)
                    {
                        l = l.Substring(2);
                        output.Add(l + " " + Signature);
                    }
                    else
                    {
                        output.Add(l); 
                    }
                }
                else 
                { 
                    output.Add(l); 
                }
            }
        }

        if (!changed)
            File.WriteAllLines(filename, output);
    }

    /*
    private static string GetGitRevision(string folder)
    {
        var p = new Process();
        // Redirect the output stream of the child process.
        p.StartInfo.UseShellExecute = false;
        p.StartInfo.RedirectStandardOutput = true;
        p.StartInfo.FileName = "git.exe";
        p.StartInfo.Arguments = "rev-list HEAD";
        p.StartInfo.WorkingDirectory = folder;
        p.Start();
        var output = p.StandardOutput.ReadToEnd();
        p.WaitForExit();
        var index = output.IndexOf('\n');
        return output.Substring(0, index);
    }

    private static DateTime GetGitDate(string filename)
    {
        return DateTime.Now;
        / *
        var parent = Path.GetDirectoryName(filename);
        var grandParent = Path.GetDirectoryName(parent);
        var greatGrandParent = Path.GetDirectoryName(grandParent);
        filename = Path.Combine(greatGrandParent!, ".git", "FETCH_HEAD");
        if (!File.Exists
        var updated = File.GetLastWriteTime(filename);
        return updated;
        * /
    }

    private static int GenerateGitRevNum(string gitRevision)
    {
        var grn = "0" + gitRevision.Substring(0, 7);
        return Convert.ToInt32(grn, 16);
    }


    private static string GenerateGitRevNum(DateTime gitDate)
    {
        var grn = gitDate.ToString("HHmmss");
        return grn;
    }
    */
    
    private static string ReplaceValues(string input)
    {
        var index = input.IndexOf('{');
        while (index >= 0)
        {
            var end = input.IndexOf('}', index+1);
            if (end >= 0)
            {
                var key = input.Substring(index+1, end-index-1);
                var colon = key.IndexOf(':');
                string? format = null;
                if (colon >= 0)
                {
                    format = key.Substring(colon + 1);
                    key = key.Substring(0, colon);
                }

                if (Values.TryGetValue(key, out var replacement))
                {
                    string f;
                    if (replacement is string s)
                        f = s;
                    else if (replacement is int i)
                        f = (format == null) ? i.ToString() : i.ToString(format);
                    else
                        f = replacement.ToString()!;
                    input = input.Substring(0, index) + f + input.Substring(end+1);
                    index += f.Length;
                }
                else
                {
                    ++index;
                }
            }
            if (index >= input.Length)
                break;
            index = input.IndexOf('{', index);
        }

        return input;
    }
}
